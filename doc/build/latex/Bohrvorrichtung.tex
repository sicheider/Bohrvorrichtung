% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}


\title{Bohrvorrichtung Documentation}
\date{Nov 18, 2016}
\release{0.0.1}
\author{Simon Heider}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Überblick}
\label{_xfcberblick:uberblick}\label{_xfcberblick::doc}\label{_xfcberblick:welcome-to-bohrvorrichtung-s-documentation}
Das nachfolende Dokument soll die Funktionsweise, sowie den Quellcode der Felgenbohrmaschine
dokumentieren. Die Bohrmaschine besteht im wesentlichen aus zwei Schrittmotoren. Einen
zentralen Rotor, welcher für die Rotation und Positionierung der Felge zuständig ist und
einer Lineareinheit, welche den Dremel positioniert und die Bohrbewegung ausführt.


\section{Ansteuerung der Motoren}
\label{_xfcberblick:ansteuerung-der-motoren}
In den Motoren sind mehrere Datensätze für zugehörige Motoroperationen gespeichert. Die wichtigsten
Parameter eines Datensatzes sind:
\begin{itemize}
\item {} 
Schrittversatz: Die Positionsveränderung in Schritten

\item {} 
Geschwindigkeit: Die Geschwindigkeit der Positionsveränderung in Hz (Schritte pro Sekunde)

\item {} 
Bewegungsmodus: Inkremental (0) oder Absolut (1). Bei einer inkrementalen Bewegung werden die Schritte im Schrittversatz zur aktuellen Position hinzuaddiert. Bei einer absoluten Bewegung positioniert sich der Motor gemessen am Ausgangspunkt.

\end{itemize}

Soll nun eine bestimmte Operation ausgeführt werden, so muss am Inputregister die entsprechende
Operation ausgewählt werden und das Startflag gesetzt werden.

Zusätzlich zu den gespeicherten Operationen kann eine ReturnToHome Operation durchgeführt werden.
Hierbei fährt der Motor auf die Nullposition zurück. Die ReturnToHome Operation wird gestartet,
indem das entsprechnede Bit am Inputregister gesetzt wird.

Eine genauere Erläuterung zur Ansteuerung finded sich im Kapitel {\hyperref[_xfcberblick:modbus\string-rs\string-485]{\sphinxcrossref{Modbus/RS-485}}},
sowie im OrientalMotor Datenblatt Kapitel 5 und in der Softwaredokumentation.


\subsection{Rotor}
\label{_xfcberblick:rotor}
Der zentrale Rotor besitzt nur einen Datensatz, welcher unter dem Index 0 gespeichert ist. Die
zugehörige Operation rotiert die Felge um einen Bohrversatz.


\subsection{Lineareinheit}
\label{_xfcberblick:lineareinheit}
In der Lineareinheit sind folgende Datensätze hinterlegt:
\begin{itemize}
\item {} 
Index 0: Verfahren zum Bohrausgangspunkt (Pos. 1 mit Geschw. 1)

\item {} 
Index 1: Verfahren zum Bohrmittelpunkt (Pos. 2 mit Geschw. 2)

\item {} 
Index 3: Verfahren zum Bohrendpunkt (Pos. 3 mit Geschw. 3)

\item {} 
Index 4: Rückbewegung zum Bohrausgangspunkt (Pos. 1 mit Geschw. 4)

\item {} 
Index 5: Verfahren zum Linearnullpunkt UNKALIBRIERT

\end{itemize}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{schemaLineareinheit}.png}
\caption{Positionen und Geschwindigkeiten der Lineareinheit}\label{_xfcberblick:id3}\end{figure}


\section{Motorkonfiguration}
\label{_xfcberblick:motorkonfiguration}
Für eine funktionsfähige und fehlerfreie Kommunikation zwischen Steuerung und Schrittmotortreiber
müssen die Treiber richtig konfiguriert sein. Folgende Einstellungen müssen überwacht werden:
\begin{itemize}
\item {} 
ID: Adresse des Motors im Modbusprotokoll

\item {} 
Transmission rate (SW2): Serielle Übertragungsgeschwindigkeit

\item {} 
Function settings switch (SW4): Protokollkonfiguration

\item {} 
Terminierungswiderstände (TERM): Konfiguration der Terminierungswiderstände

\end{itemize}


\subsection{Rotor}
\label{_xfcberblick:id1}\begin{itemize}
\item {} 
ID: 5

\item {} 
SW2: 1 (19200 BAUD)

\item {} 
SW4-No.1: OFF

\item {} 
SW4-No.2: ON

\item {} 
TERM-No.1: ON

\item {} 
TERM-No.2: OFF

\end{itemize}


\subsection{Lineareinheit}
\label{_xfcberblick:id2}\begin{itemize}
\item {} 
ID: 6

\item {} 
SW2: 1 (19200 BAUD)

\item {} 
SW4-No.1: OFF

\item {} 
SW4-No.2: ON

\item {} 
TERM-No.1: ON

\item {} 
TERM-No.2: ON

\end{itemize}


\section{Modbus/RS-485}
\label{_xfcberblick:modbus-rs-485}
Die in {\hyperref[_xfcberblick:ansteuerung\string-der\string-motoren]{\sphinxcrossref{Ansteuerung der Motoren}}} beschriebenen Datensätze lassen sich mittels
Motbus-RTU/RS-485 manipulieren. Modbus ist ein serielles
Übertragungsprotokoll auf dem Master-Slave-Prinzip. Ein Master schickt Anforderungen an einen
definierten Slave. Hat der Slave die Anfrage erhalten und bearbeitet schickt dieser eine
Antwort an den Master. Die Steuerung der Felgenbohrmaschine benutzt folgende Anfragen:
\begin{itemize}
\item {} 
writeRegister: Schreibt einen Wert in ein Register des Motortreibers

\item {} 
readRegister: Liest einen Wert aus einem Register des Motortreibers

\end{itemize}

In den verschiedenen Treiberregistern werden Prozessparameter, wie z.B. Verfahrschritte,
Verfahrgeschwindigkeit oder Beschleunigung des Motors gespeichert. Über das Inputregister (0x125)
lässt sich der Motor starten und stoppen. Über das Outputregister (0x127) können mittels readRegister
Statusinformationen über den Motor abgefragen werden. Eine genaue Dokumentation der Register
und deren Inhalte, sowie zum Modbusprotokoll findet sich im OrientalMotor Datenblatt Kapitel 5.


\section{Aufbau der Mastersteuerung/Software}
\label{_xfcberblick:aufbau-der-mastersteuerung-software}
Als Master der Modbuskommunikation kommt ein Rasperry Pi (RP) mit nachfolgend beschriebener Software zum Einsatz.
Über einen USB zu RS-485 Konverter wird eine Verbindung zwichen RP und Schrittmotoren hergestellt. Der
Konverter muss wie folgt konfiguriert sein:
\begin{itemize}
\item {} 
SW1: OFF

\item {} 
SW2: OFF

\item {} 
SW3: OFF

\item {} 
SW4: OFF

\end{itemize}

Auf dem RP läuft das Hauptprogramm der Bohrvorrichtung ({\hyperref[bohrvorrichtung:module\string-bohrvorrichtung]{\sphinxcrossref{\sphinxcode{bohrvorrichtung}}}}), welche auf einkommende
Kommandos höhrt. Sobald ein Kommando empfangen wurde, wird dieses ausgeführt.

Des Weiteren läuft ein Listenerprogramm, welches darauf wartet, dass der Druckknopf zum Starten gedrückt
wird ({\hyperref[button:module\string-button]{\sphinxcrossref{\sphinxcode{button}}}}). Wird der Knopf gedrückt, so sendet das Programm ein Startsignal an das Hauptprogramm.

Außerdem kann manuell die grafische Operfläche gestartet werden ({\hyperref[gui:module\string-gui]{\sphinxcrossref{\sphinxcode{gui}}}}). Die grafische Oberfläche
stellt ebenfalls eine Verbindung zum Hauptprogramm her und sendet je nach Benutzereingabe verschiedene
Signale an das Hauptprogramm.


\subsection{Aufbau des Hauptprogramms}
\label{_xfcberblick:aufbau-des-hauptprogramms}
Wie bereits in {\hyperref[_xfcberblick:modbus\string-rs\string-485]{\sphinxcrossref{Modbus/RS-485}}} erwähnt, werden die Schrittmotoren über das Modbusprotokoll angesteuert.
{\hyperref[minimalmodbus:module\string-minimalmodbus]{\sphinxcrossref{\sphinxcode{minimalmodbus}}}} stellt grundlegende Funktionalitäten zur Modbuskommunikation zur Verfügung. Beispielsweise
writeRegister (zum Schreiben von Prozessparametern) oder readRegister (zum Lesen von Prozessparametern).
{\hyperref[stepperMotor:module\string-stepperMotor]{\sphinxcrossref{\sphinxcode{stepperMotor}}}} erbt von {\hyperref[minimalmodbus:module\string-minimalmodbus]{\sphinxcrossref{\sphinxcode{minimalmodbus}}}} und stellt einen Schrittmotor dar. Mithilfe von
{\hyperref[stepperMotor:module\string-stepperMotor]{\sphinxcrossref{\sphinxcode{stepperMotor}}}} kann ein Schrittmotor angesteuert, also bewegt und konfiguriert, werden. Das Hauptprogramm
({\hyperref[bohrvorrichtung:module\string-bohrvorrichtung]{\sphinxcrossref{\sphinxcode{bohrvorrichtung}}}}) konstruiert sich nun zwei Instanzen von {\hyperref[stepperMotor:module\string-stepperMotor]{\sphinxcrossref{\sphinxcode{stepperMotor}}}}, welche jeweils den
Rotor beziehungsweise die Lineareinheit darstellen. Beim Initialisieren werden alle benötigten
Prozessparameter aus der Datei ``processData.json'' geladen. Die Datei entspricht dem JSON Standard.
Der gültige Aufbau wird in {\hyperref[bohrvorrichtung:module\string-bohrvorrichtung]{\sphinxcrossref{\sphinxcode{bohrvorrichtung}}}} dokumentiert. Nach dem Initialisieren wird die
Hauptschleife gestartet, welche auf einkommende Kommandos höhrt (definiert in {\hyperref[commands:module\string-commands]{\sphinxcrossref{\sphinxcode{commands}}}}).
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{bohrvorrichtungUML}.png}
\caption{UML Diagramm der Steuerungssoftware}\label{_xfcberblick:id4}\end{figure}


\subsection{Aufbau der Interprozesskommunikation}
\label{_xfcberblick:aufbau-der-interprozesskommunikation}
Die Kommunikation zwischen {\hyperref[gui:module\string-gui]{\sphinxcrossref{\sphinxcode{gui}}}}, {\hyperref[button:module\string-button]{\sphinxcrossref{\sphinxcode{button}}}} und {\hyperref[bohrvorrichtung:module\string-bohrvorrichtung]{\sphinxcrossref{\sphinxcode{bohrvorrichtung}}}} wird von
{\hyperref[communicationUtilities:module\string-communicationUtilities]{\sphinxcrossref{\sphinxcode{communicationUtilities}}}} gesteuert. {\hyperref[bohrvorrichtung:module\string-bohrvorrichtung]{\sphinxcrossref{\sphinxcode{bohrvorrichtung}}}} besitzt eine Instanz der Klasse
{\hyperref[communicationUtilities:communicationUtilities.CommandReceiver]{\sphinxcrossref{\sphinxcode{communicationUtilities.CommandReceiver}}}} welche auf neue Verbindungen höhrt und Kommandos
empfängt. Das Hauptprogramm kann dann empfangene Befehle aus der Warteschlange von
{\hyperref[communicationUtilities:communicationUtilities.CommandReceiver]{\sphinxcrossref{\sphinxcode{communicationUtilities.CommandReceiver}}}} nehmen und nach deren Ausführung die entsprechende
Antwort in die Ausgangswarteschlange von {\hyperref[communicationUtilities:communicationUtilities.CommandReceiver]{\sphinxcrossref{\sphinxcode{communicationUtilities.CommandReceiver}}}} schreiben.

{\hyperref[gui:module\string-gui]{\sphinxcrossref{\sphinxcode{gui}}}} und {\hyperref[button:module\string-button]{\sphinxcrossref{\sphinxcode{button}}}} besitzen jeweils eine Instanz der Klasse
{\hyperref[communicationUtilities:communicationUtilities.CommandSender]{\sphinxcrossref{\sphinxcode{communicationUtilities.CommandSender}}}},
welche zuerst eine Verbindung zu {\hyperref[communicationUtilities:communicationUtilities.CommandReceiver]{\sphinxcrossref{\sphinxcode{communicationUtilities.CommandReceiver}}}}
aufbaut und danach Befehle an die Gegenseite verschicken kann. Eine Sender darf erst ein neues
Kommando verschicken, wenn ein Rückmeldung vom alten Kommando erhalten wurde. Ein Interrupt zum
Stop der Maschine darf jedoch jederzeit gesendet werden.


\chapter{Bohrvorrichtung Quellcodedokumentation}
\label{modules::doc}\label{modules:bohrvorrichtung-quellcodedokumentation}

\section{bohrvorrichtung module}
\label{bohrvorrichtung::doc}\label{bohrvorrichtung:bohrvorrichtung-module}\label{bohrvorrichtung:module-bohrvorrichtung}\index{bohrvorrichtung (module)}\index{Bohrvorrichtung (class in bohrvorrichtung)}

\begin{fulllineitems}
\phantomsection\label{bohrvorrichtung:bohrvorrichtung.Bohrvorrichtung}\pysigline{\sphinxstrong{class }\sphinxcode{bohrvorrichtung.}\sphinxbfcode{Bohrvorrichtung}}
Bases: \sphinxcode{object}

The actual driller. Starts listening on commands when {\hyperref[bohrvorrichtung:bohrvorrichtung.Bohrvorrichtung.start]{\sphinxcrossref{\sphinxcode{start()}}}} is called!
\begin{description}
\item[{Attributes:}] \leavevmode\begin{itemize}
\item {} 
rotor: The rotor stepper motor

\item {} 
linear: The linear stepper motor

\item {} 
isInterrupted: Flag if driller is interrupted or not

\item {} 
mainLoopWaitTime: Timeout for mainloop

\item {} 
cr: Instance of CommandReceiver; Handles all incoming command requests

\end{itemize}

\end{description}
\index{\_\_init\_\_() (bohrvorrichtung.Bohrvorrichtung method)}

\begin{fulllineitems}
\phantomsection\label{bohrvorrichtung:bohrvorrichtung.Bohrvorrichtung.__init__}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{}{}
Constructor. Initializes everythin.

\end{fulllineitems}

\index{driveLinearTo() (bohrvorrichtung.Bohrvorrichtung method)}

\begin{fulllineitems}
\phantomsection\label{bohrvorrichtung:bohrvorrichtung.Bohrvorrichtung.driveLinearTo}\pysiglinewithargsret{\sphinxbfcode{driveLinearTo}}{\emph{position}}{}
Drives linear to given position.

\end{fulllineitems}

\index{handleCommand() (bohrvorrichtung.Bohrvorrichtung method)}

\begin{fulllineitems}
\phantomsection\label{bohrvorrichtung:bohrvorrichtung.Bohrvorrichtung.handleCommand}\pysiglinewithargsret{\sphinxbfcode{handleCommand}}{\emph{command}}{}
Parses a incomming command and performs an action.
\begin{description}
\item[{Returns:}] \leavevmode
SUCCESS, FAIL or INVALID\_REQUEST

\end{description}

\end{fulllineitems}

\index{handleInterrupt() (bohrvorrichtung.Bohrvorrichtung method)}

\begin{fulllineitems}
\phantomsection\label{bohrvorrichtung:bohrvorrichtung.Bohrvorrichtung.handleInterrupt}\pysiglinewithargsret{\sphinxbfcode{handleInterrupt}}{}{}
Interrupts the driller. All motors are STOPPED.

\end{fulllineitems}

\index{loadProcessData() (bohrvorrichtung.Bohrvorrichtung method)}

\begin{fulllineitems}
\phantomsection\label{bohrvorrichtung:bohrvorrichtung.Bohrvorrichtung.loadProcessData}\pysiglinewithargsret{\sphinxbfcode{loadProcessData}}{}{}
Loads process data from json file. The json file must define:
\begin{description}
\item[{Attributes:}] \leavevmode\begin{itemize}
\item {} 
holeNumber: The ammount of holes

\item {} 
rotorSteps: The steps for each rotor move

\item {} 
rotorOperationSpeed

\item {} 
rotorOperationMode

\item {} 
x1: The position where drilling starts

\item {} 
x2: The middleposition of drilling

\item {} 
x3: The position where drilling ends

\item {} 
x4: The position where drilling starts

\item {} 
x5: Nullposition

\item {} 
v1: Speed to x1

\item {} 
v2: Speed to x2

\item {} 
v3: Speed to x3

\item {} 
v4: Speed to x4

\item {} 
v5: Speed to x5

\item {} 
mode1

\item {} 
mode2

\item {} 
mode3

\item {} 
mode4

\item {} 
mode5

\end{itemize}

\end{description}

\end{fulllineitems}

\index{processDataToDevice() (bohrvorrichtung.Bohrvorrichtung method)}

\begin{fulllineitems}
\phantomsection\label{bohrvorrichtung:bohrvorrichtung.Bohrvorrichtung.processDataToDevice}\pysiglinewithargsret{\sphinxbfcode{processDataToDevice}}{}{}
Loads and writes process data.

\end{fulllineitems}

\index{sayHello() (bohrvorrichtung.Bohrvorrichtung method)}

\begin{fulllineitems}
\phantomsection\label{bohrvorrichtung:bohrvorrichtung.Bohrvorrichtung.sayHello}\pysiglinewithargsret{\sphinxbfcode{sayHello}}{}{}
Process initial movement.

\end{fulllineitems}

\index{start() (bohrvorrichtung.Bohrvorrichtung method)}

\begin{fulllineitems}
\phantomsection\label{bohrvorrichtung:bohrvorrichtung.Bohrvorrichtung.start}\pysiglinewithargsret{\sphinxbfcode{start}}{}{}
Starts mainloop and listens to incoming commands.
For valid commands see {\hyperref[commands:module\string-commands]{\sphinxcrossref{\sphinxcode{commands}}}}

\end{fulllineitems}

\index{startDrilling() (bohrvorrichtung.Bohrvorrichtung method)}

\begin{fulllineitems}
\phantomsection\label{bohrvorrichtung:bohrvorrichtung.Bohrvorrichtung.startDrilling}\pysiglinewithargsret{\sphinxbfcode{startDrilling}}{}{}
Perform drilling process.

\end{fulllineitems}

\index{writeProcessData() (bohrvorrichtung.Bohrvorrichtung method)}

\begin{fulllineitems}
\phantomsection\label{bohrvorrichtung:bohrvorrichtung.Bohrvorrichtung.writeProcessData}\pysiglinewithargsret{\sphinxbfcode{writeProcessData}}{}{}
Writes process data to stepper motor registers.

\end{fulllineitems}


\end{fulllineitems}



\section{button module}
\label{button::doc}\label{button:module-button}\label{button:button-module}\index{button (module)}\index{Button (class in button)}

\begin{fulllineitems}
\phantomsection\label{button:button.Button}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{button.}\sphinxbfcode{Button}}{\emph{buttonPin=18}}{}
Bases: \sphinxcode{object}

Button which is attached to rasperry pi.
\begin{description}
\item[{Attributes:}] \leavevmode\begin{itemize}
\item {} 
buttonPin: GPIO pin where the button is connected to

\item {} 
allowedToSend: indicates if button is allowed to send a command or not; Button is not allowed to change this value by itself

\item {} 
cs: An instance of CommandSender, which sends starting commands to the driller

\end{itemize}

\end{description}
\index{\_\_init\_\_() (button.Button method)}

\begin{fulllineitems}
\phantomsection\label{button:button.Button.__init__}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{buttonPin=18}}{}
Constructor; sets attributes.
\begin{description}
\item[{Args:}] \leavevmode
see attributes

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
None

\end{description}

\end{fulllineitems}

\index{onResponse() (button.Button method)}

\begin{fulllineitems}
\phantomsection\label{button:button.Button.onResponse}\pysiglinewithargsret{\sphinxbfcode{onResponse}}{\emph{response}}{}
Printing the command response.

\end{fulllineitems}

\index{start() (button.Button method)}

\begin{fulllineitems}
\phantomsection\label{button:button.Button.start}\pysiglinewithargsret{\sphinxbfcode{start}}{}{}
Listens if the button is pressed and sends a starting command to the driller,
if its allowed to.

\end{fulllineitems}


\end{fulllineitems}



\section{commands module}
\label{commands:commands-module}\label{commands::doc}\label{commands:module-commands}\index{commands (module)}
This module defines all command request a command sender (such as gui or button) can send to
the driller and their responses.
\index{INTERRUPT (in module commands)}

\begin{fulllineitems}
\phantomsection\label{commands:commands.INTERRUPT}\pysigline{\sphinxcode{commands.}\sphinxbfcode{INTERRUPT}\sphinxstrong{ = `interrupt'}}
The driller is interrupted and stops all movement.

\end{fulllineitems}

\index{REQUEST\_DRIVEX1 (in module commands)}

\begin{fulllineitems}
\phantomsection\label{commands:commands.REQUEST_DRIVEX1}\pysigline{\sphinxcode{commands.}\sphinxbfcode{REQUEST\_DRIVEX1}\sphinxstrong{ = `driveToX1'}}
Linear is driving to startposition of drilling.

\end{fulllineitems}

\index{REQUEST\_DRIVEX2 (in module commands)}

\begin{fulllineitems}
\phantomsection\label{commands:commands.REQUEST_DRIVEX2}\pysigline{\sphinxcode{commands.}\sphinxbfcode{REQUEST\_DRIVEX2}\sphinxstrong{ = `driveToX2'}}
Linear is driving to middleposition of drilling.

\end{fulllineitems}

\index{REQUEST\_DRIVEX3 (in module commands)}

\begin{fulllineitems}
\phantomsection\label{commands:commands.REQUEST_DRIVEX3}\pysigline{\sphinxcode{commands.}\sphinxbfcode{REQUEST\_DRIVEX3}\sphinxstrong{ = `driveToX3'}}
Linear is driving to endposition of drilling.

\end{fulllineitems}

\index{REQUEST\_RELOADDATA (in module commands)}

\begin{fulllineitems}
\phantomsection\label{commands:commands.REQUEST_RELOADDATA}\pysigline{\sphinxcode{commands.}\sphinxbfcode{REQUEST\_RELOADDATA}\sphinxstrong{ = `reloadData'}}
The Processdata is reloaded from the processData file and is written to the motors.

\end{fulllineitems}

\index{REQUEST\_STARTDRILLING (in module commands)}

\begin{fulllineitems}
\phantomsection\label{commands:commands.REQUEST_STARTDRILLING}\pysigline{\sphinxcode{commands.}\sphinxbfcode{REQUEST\_STARTDRILLING}\sphinxstrong{ = `startDrilling'}}
Starts the drilling process.

\end{fulllineitems}

\index{RESPONSE\_FAIL (in module commands)}

\begin{fulllineitems}
\phantomsection\label{commands:commands.RESPONSE_FAIL}\pysigline{\sphinxcode{commands.}\sphinxbfcode{RESPONSE\_FAIL}\sphinxstrong{ = `fail'}}
When the operation was unsuccessfull.

\end{fulllineitems}

\index{RESPONSE\_INVALID\_REQUEST (in module commands)}

\begin{fulllineitems}
\phantomsection\label{commands:commands.RESPONSE_INVALID_REQUEST}\pysigline{\sphinxcode{commands.}\sphinxbfcode{RESPONSE\_INVALID\_REQUEST}\sphinxstrong{ = `invalidRequest'}}
When a invalid request was send.

\end{fulllineitems}

\index{RESPONSE\_SUCCESS (in module commands)}

\begin{fulllineitems}
\phantomsection\label{commands:commands.RESPONSE_SUCCESS}\pysigline{\sphinxcode{commands.}\sphinxbfcode{RESPONSE\_SUCCESS}\sphinxstrong{ = `success'}}
When the operation was successfull.

\end{fulllineitems}



\section{communicationUtilities module}
\label{communicationUtilities:module-communicationUtilities}\label{communicationUtilities:communicationutilities-module}\label{communicationUtilities::doc}\index{communicationUtilities (module)}\index{CommandReceiver (class in communicationUtilities)}

\begin{fulllineitems}
\phantomsection\label{communicationUtilities:communicationUtilities.CommandReceiver}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{communicationUtilities.}\sphinxbfcode{CommandReceiver}}{\emph{master}, \emph{host='`}, \emph{port=54321}, \emph{timeout=0.2}}{}
Bases: \sphinxcode{threading.Thread}

Receives command requests and sends command responses.
\begin{description}
\item[{Attributes:}] \leavevmode\begin{itemize}
\item {} 
master: A class that handles the commands; must have a boolean attribute named ``isInterrupted''

\item {} 
connections: A list where all connections are stored

\item {} 
commandRequests: A queue where all received (commandRequests, con) are stored

\item {} 
commandResponses: A queue where all (commandResponses, con) are stored, which have to be send

\item {} 
timeout: Blocking time for reading sockets

\item {} 
ca: An instance of ConnectionAcceptor which accepts new connections and writes them to connections

\end{itemize}

\end{description}
\index{\_\_init\_\_() (communicationUtilities.CommandReceiver method)}

\begin{fulllineitems}
\phantomsection\label{communicationUtilities:communicationUtilities.CommandReceiver.__init__}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{master}, \emph{host='`}, \emph{port=54321}, \emph{timeout=0.2}}{}
Constructor; sets attributes and starts ConnectionAcceptor
\begin{description}
\item[{Args:}] \leavevmode
see Attributes

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
None

\end{description}

\end{fulllineitems}

\index{receiveCommandRequests() (communicationUtilities.CommandReceiver method)}

\begin{fulllineitems}
\phantomsection\label{communicationUtilities:communicationUtilities.CommandReceiver.receiveCommandRequests}\pysiglinewithargsret{\sphinxbfcode{receiveCommandRequests}}{}{}
Reads all incoming command requests and writes them to commandRequests.
Interrupts the master, if necessary.
\begin{description}
\item[{Args:}] \leavevmode
None

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
None

\end{description}

\end{fulllineitems}

\index{run() (communicationUtilities.CommandReceiver method)}

\begin{fulllineitems}
\phantomsection\label{communicationUtilities:communicationUtilities.CommandReceiver.run}\pysiglinewithargsret{\sphinxbfcode{run}}{}{}
Starts main receiving and sending loop in a thread.

\end{fulllineitems}

\index{sendCommandResponses() (communicationUtilities.CommandReceiver method)}

\begin{fulllineitems}
\phantomsection\label{communicationUtilities:communicationUtilities.CommandReceiver.sendCommandResponses}\pysiglinewithargsret{\sphinxbfcode{sendCommandResponses}}{}{}
Sends all command responses stored in commandResponses.
\begin{description}
\item[{Args:}] \leavevmode
None

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
None

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{CommandSender (class in communicationUtilities)}

\begin{fulllineitems}
\phantomsection\label{communicationUtilities:communicationUtilities.CommandSender}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{communicationUtilities.}\sphinxbfcode{CommandSender}}{\emph{master}, \emph{host='localhost'}, \emph{port=54321}, \emph{timeout=0.2}}{}
Bases: \sphinxcode{threading.Thread}

Class to send command requests and wait for command responses.
\begin{description}
\item[{Attributes:}] \leavevmode\begin{itemize}
\item {} 
master: A class which wants to send command requests; must have a boolean attributes named ``allowedToSend'' and and implement a method onResponse(response)

\item {} 
sendInterrupt: If true CommandSender sends an interrupt command to CommandReceiver

\item {} 
timeout: Blocking time for reading socket

\item {} 
s: socket, which is connected to a commandReceiver

\item {} 
commandRequestToSend: The command which will be send in the next iteration of the main loop

\end{itemize}

\end{description}
\index{\_\_init\_\_() (communicationUtilities.CommandSender method)}

\begin{fulllineitems}
\phantomsection\label{communicationUtilities:communicationUtilities.CommandSender.__init__}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{master}, \emph{host='localhost'}, \emph{port=54321}, \emph{timeout=0.2}}{}
Constructor; sets attributes and connects the socket to a CommandReceiver.
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
host: host to connect to

\item {} 
port: port to connect to

\item {} 
rest: see attributes

\end{itemize}

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
None

\end{description}

\end{fulllineitems}

\index{receiveResponse() (communicationUtilities.CommandSender method)}

\begin{fulllineitems}
\phantomsection\label{communicationUtilities:communicationUtilities.CommandSender.receiveResponse}\pysiglinewithargsret{\sphinxbfcode{receiveResponse}}{}{}
Waits until a command response has arrived. Sends an interrupt command if necessary.
\begin{description}
\item[{Args:}] \leavevmode
None

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
None

\end{description}

\end{fulllineitems}

\index{run() (communicationUtilities.CommandSender method)}

\begin{fulllineitems}
\phantomsection\label{communicationUtilities:communicationUtilities.CommandSender.run}\pysiglinewithargsret{\sphinxbfcode{run}}{}{}
\end{fulllineitems}

\index{sendRequest() (communicationUtilities.CommandSender method)}

\begin{fulllineitems}
\phantomsection\label{communicationUtilities:communicationUtilities.CommandSender.sendRequest}\pysiglinewithargsret{\sphinxbfcode{sendRequest}}{}{}
Sends the commandRequestToSend request to a CommandReceiver. Waits for the response in a thread.
\begin{description}
\item[{Args:}] \leavevmode
None

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
None

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{ConnectionAcceptor (class in communicationUtilities)}

\begin{fulllineitems}
\phantomsection\label{communicationUtilities:communicationUtilities.ConnectionAcceptor}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{communicationUtilities.}\sphinxbfcode{ConnectionAcceptor}}{\emph{master}, \emph{host}, \emph{port}}{}
Bases: \sphinxcode{threading.Thread}

Class for accepting new socet connections in a thread.
\begin{description}
\item[{Attributes:}] \leavevmode\begin{itemize}
\item {} 
master: Class which handles the connections; must have a list as attribute named ``connections''

\item {} 
host: host ipadress

\item {} 
port: port to listen

\end{itemize}

\end{description}
\index{\_\_init\_\_() (communicationUtilities.ConnectionAcceptor method)}

\begin{fulllineitems}
\phantomsection\label{communicationUtilities:communicationUtilities.ConnectionAcceptor.__init__}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{master}, \emph{host}, \emph{port}}{}
Constructor; sets the attributes.
Args:
\begin{quote}

see Attributes
\end{quote}
\begin{description}
\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
None

\end{description}

\end{fulllineitems}

\index{run() (communicationUtilities.ConnectionAcceptor method)}

\begin{fulllineitems}
\phantomsection\label{communicationUtilities:communicationUtilities.ConnectionAcceptor.run}\pysiglinewithargsret{\sphinxbfcode{run}}{}{}
Start main listeningloop and writes new connections to connectionWorker.connections.
\begin{description}
\item[{Args:}] \leavevmode
None

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
None

\end{description}

\end{fulllineitems}


\end{fulllineitems}



\section{gui module}
\label{gui:module-gui}\label{gui:gui-module}\label{gui::doc}\index{gui (module)}\index{Gui (class in gui)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui}\pysigline{\sphinxstrong{class }\sphinxcode{gui.}\sphinxbfcode{Gui}}
Bases: \sphinxcode{PyQt4.QtGui.QDialog}

The gui to configure the driller.
\begin{description}
\item[{Attributes:}] \leavevmode\begin{itemize}
\item {} 
receivedResponse: The signal which is emmited if the gui has received an answer

\item {} 
ui: The interface

\item {} 
cs: The sender which sends commands to the driller

\item {} 
allowedToSend: A flag which indicates, if the gui is allowed to send commands

\item {} 
allProcessData: A list of dictionarys which stores all process data. See {\hyperref[gui:gui.Gui.loadAllProcessData]{\sphinxcrossref{\sphinxcode{loadAllProcessData()}}}}

\item {} 
allProcessDataFileName: The json file where all process data are stored

\end{itemize}

\end{description}
\index{\_\_init\_\_() (gui.Gui method)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.__init__}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{}{}
\end{fulllineitems}

\index{closeEvent() (gui.Gui method)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.closeEvent}\pysiglinewithargsret{\sphinxbfcode{closeEvent}}{}{}
\end{fulllineitems}

\index{disableWidgets() (gui.Gui method)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.disableWidgets}\pysiglinewithargsret{\sphinxbfcode{disableWidgets}}{}{}
Disables all widgets.

\end{fulllineitems}

\index{enableWidgets() (gui.Gui method)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.enableWidgets}\pysiglinewithargsret{\sphinxbfcode{enableWidgets}}{}{}
Enables all widgets.

\end{fulllineitems}

\index{getDataFromEdits() (gui.Gui method)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.getDataFromEdits}\pysiglinewithargsret{\sphinxbfcode{getDataFromEdits}}{}{}
Reads from input edits.
\begin{description}
\item[{Args:}] \leavevmode
None

\item[{Returns:}] \leavevmode
A dict with process data information. See {\hyperref[gui:gui.Gui.loadAllProcessData]{\sphinxcrossref{\sphinxcode{loadAllProcessData()}}}}

\item[{Raises:}] \leavevmode
ValueError

\end{description}

\end{fulllineitems}

\index{getProcessDataByName() (gui.Gui method)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.getProcessDataByName}\pysiglinewithargsret{\sphinxbfcode{getProcessDataByName}}{\emph{name}}{}
\end{fulllineitems}

\index{loadAllProcessData() (gui.Gui method)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.loadAllProcessData}\pysiglinewithargsret{\sphinxbfcode{loadAllProcessData}}{}{}
Loads all process data from the json file and stores them into allProcessData.
One process data must define the following:
\begin{description}
\item[{Attributes:}] \leavevmode\begin{itemize}
\item {} 
holeNumber: The ammount of holes

\item {} 
rotorSteps: The steps for each rotor move

\item {} 
rotorOperationSpeed

\item {} 
rotorOperationMode

\item {} 
x1: The position where drilling starts

\item {} 
x2: The middleposition of drilling

\item {} 
x3: The position where drilling ends

\item {} 
x4: The position where drilling starts

\item {} 
x5: Nullposition

\item {} 
v1: Speed to x1

\item {} 
v2: Speed to x2

\item {} 
v3: Speed to x3

\item {} 
v4: Speed to x4

\item {} 
v5: Speed to x5

\item {} 
mode1

\item {} 
mode2

\item {} 
mode3

\item {} 
mode4

\item {} 
mode5

\end{itemize}

\end{description}

\end{fulllineitems}

\index{onComboBoxChanged() (gui.Gui method)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.onComboBoxChanged}\pysiglinewithargsret{\sphinxbfcode{onComboBoxChanged}}{}{}
Updates gui after combo box index change.

\end{fulllineitems}

\index{onDeleteButtonClicked() (gui.Gui method)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.onDeleteButtonClicked}\pysiglinewithargsret{\sphinxbfcode{onDeleteButtonClicked}}{}{}
Deletes current process data and updates allProcess data file.

\end{fulllineitems}

\index{onDriveToX1ButtonClicked() (gui.Gui method)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.onDriveToX1ButtonClicked}\pysiglinewithargsret{\sphinxbfcode{onDriveToX1ButtonClicked}}{}{}
\end{fulllineitems}

\index{onDriveToX2ButtonClicked() (gui.Gui method)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.onDriveToX2ButtonClicked}\pysiglinewithargsret{\sphinxbfcode{onDriveToX2ButtonClicked}}{}{}
\end{fulllineitems}

\index{onDriveToX3ButtonClicked() (gui.Gui method)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.onDriveToX3ButtonClicked}\pysiglinewithargsret{\sphinxbfcode{onDriveToX3ButtonClicked}}{}{}
\end{fulllineitems}

\index{onReceiveResponseEvent() (gui.Gui method)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.onReceiveResponseEvent}\pysiglinewithargsret{\sphinxbfcode{onReceiveResponseEvent}}{\emph{response}}{}
Gets called when a response was received. Displays respone information
and enables widges.

\end{fulllineitems}

\index{onResponse() (gui.Gui method)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.onResponse}\pysiglinewithargsret{\sphinxbfcode{onResponse}}{\emph{response}}{}
\end{fulllineitems}

\index{onSaveButtonClicked() (gui.Gui method)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.onSaveButtonClicked}\pysiglinewithargsret{\sphinxbfcode{onSaveButtonClicked}}{}{}
Saves current process data to allProcessData and writes it to file.

\end{fulllineitems}

\index{onSaveDataAndLoadButtonClicked() (gui.Gui method)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.onSaveDataAndLoadButtonClicked}\pysiglinewithargsret{\sphinxbfcode{onSaveDataAndLoadButtonClicked}}{}{}
Saves process data and sends reload command.

\end{fulllineitems}

\index{onStartButtonClicked() (gui.Gui method)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.onStartButtonClicked}\pysiglinewithargsret{\sphinxbfcode{onStartButtonClicked}}{}{}
\end{fulllineitems}

\index{onStopButtonClicked() (gui.Gui method)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.onStopButtonClicked}\pysiglinewithargsret{\sphinxbfcode{onStopButtonClicked}}{}{}
\end{fulllineitems}

\index{receivedResponse (gui.Gui attribute)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.receivedResponse}\pysigline{\sphinxbfcode{receivedResponse}}
\end{fulllineitems}

\index{refreshDataEdits() (gui.Gui method)}

\begin{fulllineitems}
\phantomsection\label{gui:gui.Gui.refreshDataEdits}\pysiglinewithargsret{\sphinxbfcode{refreshDataEdits}}{\emph{processData}}{}
Refreshes input edits with given values.
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
processData: A dict with process data. See {\hyperref[gui:gui.Gui.loadAllProcessData]{\sphinxcrossref{\sphinxcode{loadAllProcessData()}}}}

\end{itemize}

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
None

\end{description}

\end{fulllineitems}


\end{fulllineitems}



\section{minimalmodbus module}
\label{minimalmodbus:module-minimalmodbus}\label{minimalmodbus::doc}\label{minimalmodbus:minimalmodbus-module}\index{minimalmodbus (module)}
MinimalModbus: A Python driver for the Modbus RTU and Modbus ASCII protocols via serial port (via RS485 or RS232).
\index{BAUDRATE (in module minimalmodbus)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.BAUDRATE}\pysigline{\sphinxcode{minimalmodbus.}\sphinxbfcode{BAUDRATE}\sphinxstrong{ = 19200}}
Default value for the baudrate in Baud (int).

\end{fulllineitems}

\index{BYTESIZE (in module minimalmodbus)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.BYTESIZE}\pysigline{\sphinxcode{minimalmodbus.}\sphinxbfcode{BYTESIZE}\sphinxstrong{ = 8}}
Default value for the bytesize (int).

\end{fulllineitems}

\index{CLOSE\_PORT\_AFTER\_EACH\_CALL (in module minimalmodbus)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.CLOSE_PORT_AFTER_EACH_CALL}\pysigline{\sphinxcode{minimalmodbus.}\sphinxbfcode{CLOSE\_PORT\_AFTER\_EACH\_CALL}\sphinxstrong{ = False}}
Default value for port closure setting.

\end{fulllineitems}

\index{Instrument (class in minimalmodbus)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{minimalmodbus.}\sphinxbfcode{Instrument}}{\emph{port}, \emph{slaveaddress}, \emph{mode='rtu'}}{}
Bases: \sphinxcode{object}

Instrument class for talking to instruments (slaves) via the Modbus RTU or ASCII protocols (via RS485 or RS232).
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
port (str): The serial port name, for example \sphinxcode{/dev/ttyUSB0} (Linux), \sphinxcode{/dev/tty.usbserial} (OS X) or \sphinxcode{COM4} (Windows).

\item {} 
slaveaddress (int): Slave address in the range 1 to 247 (use decimal numbers, not hex).

\item {} 
mode (str): Mode selection. Can be MODE\_RTU or MODE\_ASCII.

\end{itemize}

\end{description}
\index{\_\_init\_\_() (minimalmodbus.Instrument method)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument.__init__}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{port}, \emph{slaveaddress}, \emph{mode='rtu'}}{}
\end{fulllineitems}

\index{address (minimalmodbus.Instrument attribute)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument.address}\pysigline{\sphinxbfcode{address}\sphinxstrong{ = None}}
Slave address (int). Most often set by the constructor (see the class documentation).

\end{fulllineitems}

\index{close\_port\_after\_each\_call (minimalmodbus.Instrument attribute)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument.close_port_after_each_call}\pysigline{\sphinxbfcode{close\_port\_after\_each\_call}\sphinxstrong{ = None}}
If this is \sphinxcode{True}, the serial port will be closed after each call. Defaults to {\hyperref[minimalmodbus:minimalmodbus.CLOSE_PORT_AFTER_EACH_CALL]{\sphinxcrossref{\sphinxcode{CLOSE\_PORT\_AFTER\_EACH\_CALL}}}}. To change it, set the value \sphinxcode{minimalmodbus.CLOSE\_PORT\_AFTER\_EACH\_CALL=True} .

\end{fulllineitems}

\index{debug (minimalmodbus.Instrument attribute)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument.debug}\pysigline{\sphinxbfcode{debug}\sphinxstrong{ = None}}
Set this to \sphinxcode{True} to print the communication details. Defaults to \sphinxcode{False}.

\end{fulllineitems}

\index{handle\_local\_echo (minimalmodbus.Instrument attribute)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument.handle_local_echo}\pysigline{\sphinxbfcode{handle\_local\_echo}\sphinxstrong{ = None}}
Set to to \sphinxcode{True} if your RS-485 adaptor has local echo enabled.
Then the transmitted message will immeadiately appear at the receive line of the RS-485 adaptor.
MinimalModbus will then read and discard this data, before reading the data from the slave.
Defaults to \sphinxcode{False}.

New in version 0.7.

\end{fulllineitems}

\index{mode (minimalmodbus.Instrument attribute)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument.mode}\pysigline{\sphinxbfcode{mode}\sphinxstrong{ = None}}
Slave mode (str), can be MODE\_RTU or MODE\_ASCII.  Most often set by the constructor (see the class documentation).

New in version 0.6.

\end{fulllineitems}

\index{precalculate\_read\_size (minimalmodbus.Instrument attribute)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument.precalculate_read_size}\pysigline{\sphinxbfcode{precalculate\_read\_size}\sphinxstrong{ = None}}
If this is \sphinxcode{False}, the serial port reads until timeout
instead of just reading a specific number of bytes. Defaults to \sphinxcode{True}.

New in version 0.5.

\end{fulllineitems}

\index{read\_bit() (minimalmodbus.Instrument method)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument.read_bit}\pysiglinewithargsret{\sphinxbfcode{read\_bit}}{\emph{registeraddress}, \emph{functioncode=2}}{}
Read one bit from the slave.
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
registeraddress (int): The slave register address (use decimal numbers, not hex).

\item {} 
functioncode (int): Modbus function code. Can be 1 or 2.

\end{itemize}

\item[{Returns:}] \leavevmode
The bit value 0 or 1 (int).

\item[{Raises:}] \leavevmode
ValueError, TypeError, IOError

\end{description}

\end{fulllineitems}

\index{read\_float() (minimalmodbus.Instrument method)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument.read_float}\pysiglinewithargsret{\sphinxbfcode{read\_float}}{\emph{registeraddress}, \emph{functioncode=3}, \emph{numberOfRegisters=2}}{}
Read a floating point number from the slave.

Floats are stored in two or more consecutive 16-bit registers in the slave. The
encoding is according to the standard IEEE 754.

There are differences in the byte order used by different manufacturers. A floating
point value of 1.0 is encoded (in single precision) as 3f800000 (hex). In this
implementation the data will be sent as \sphinxcode{'\textbackslash{}x3f\textbackslash{}x80'} and \sphinxcode{'\textbackslash{}x00\textbackslash{}x00'}
to two consecutetive registers . Make sure to test that it makes sense for your instrument.
It is pretty straight-forward to change this code if some other byte order is
required by anyone (see support section).
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
registeraddress (int): The slave register start address (use decimal numbers, not hex).

\item {} 
functioncode (int): Modbus function code. Can be 3 or 4.

\item {} 
numberOfRegisters (int): The number of registers allocated for the float. Can be 2 or 4.

\end{itemize}

\end{description}

\noindent\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
Type of floating point number in slave
\unskip}\relax &\textsf{\relax 
Size
\unskip}\relax &\textsf{\relax 
Registers
\unskip}\relax &\textsf{\relax 
Range
\unskip}\relax \\
\hline
Single precision (binary32)
&
32 bits (4 bytes)
&
2 registers
&
1.4E-45 to 3.4E38
\\
\hline
Double precision (binary64)
&
64 bits (8 bytes)
&
4 registers
&
5E-324 to 1.8E308
\\
\hline\end{tabulary}

\begin{description}
\item[{Returns:}] \leavevmode
The numerical value (float).

\item[{Raises:}] \leavevmode
ValueError, TypeError, IOError

\end{description}

\end{fulllineitems}

\index{read\_long() (minimalmodbus.Instrument method)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument.read_long}\pysiglinewithargsret{\sphinxbfcode{read\_long}}{\emph{registeraddress}, \emph{functioncode=3}, \emph{signed=False}}{}
Read a long integer (32 bits) from the slave.

Long integers (32 bits = 4 bytes) are stored in two consecutive 16-bit registers in the slave.
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
registeraddress (int): The slave register start address (use decimal numbers, not hex).

\item {} 
functioncode (int): Modbus function code. Can be 3 or 4.

\item {} 
signed (bool): Whether the data should be interpreted as unsigned or signed.

\end{itemize}

\end{description}

\noindent\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
\sphinxcode{signed}
\unskip}\relax &\textsf{\relax 
Data type in slave
\unskip}\relax &\textsf{\relax 
Alternative name
\unskip}\relax &\textsf{\relax 
Range
\unskip}\relax \\
\hline
\sphinxcode{False}
&
Unsigned INT32
&
Unsigned long
&
0 to 4294967295
\\
\hline
\sphinxcode{True}
&
INT32
&
Long
&
-2147483648 to 2147483647
\\
\hline\end{tabulary}

\begin{description}
\item[{Returns:}] \leavevmode
The numerical value (int).

\item[{Raises:}] \leavevmode
ValueError, TypeError, IOError

\end{description}

\end{fulllineitems}

\index{read\_register() (minimalmodbus.Instrument method)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument.read_register}\pysiglinewithargsret{\sphinxbfcode{read\_register}}{\emph{registeraddress}, \emph{numberOfDecimals=0}, \emph{functioncode=3}, \emph{signed=False}}{}
Read an integer from one 16-bit register in the slave, possibly scaling it.

The slave register can hold integer values in the range 0 to 65535 (``Unsigned INT16'').
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
registeraddress (int): The slave register address (use decimal numbers, not hex).

\item {} 
numberOfDecimals (int): The number of decimals for content conversion.

\item {} 
functioncode (int): Modbus function code. Can be 3 or 4.

\item {} 
signed (bool): Whether the data should be interpreted as unsigned or signed.

\end{itemize}

\end{description}

If a value of 77.0 is stored internally in the slave register as 770, then use \sphinxcode{numberOfDecimals=1}
which will divide the received data by 10 before returning the value.

Similarly \sphinxcode{numberOfDecimals=2} will divide the received data by 100 before returning the value.

Some manufacturers allow negative values for some registers. Instead of
an allowed integer range 0 to 65535, a range -32768 to 32767 is allowed. This is
implemented as any received value in the upper range (32768 to 65535) is
interpreted as negative value (in the range -32768 to -1).

Use the parameter \sphinxcode{signed=True} if reading from a register that can hold
negative values. Then upper range data will be automatically converted into
negative return values (two's complement).

\noindent\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
\sphinxcode{signed}
\unskip}\relax &\textsf{\relax 
Data type in slave
\unskip}\relax &\textsf{\relax 
Alternative name
\unskip}\relax &\textsf{\relax 
Range
\unskip}\relax \\
\hline
\sphinxcode{False}
&
Unsigned INT16
&
Unsigned short
&
0 to 65535
\\
\hline
\sphinxcode{True}
&
INT16
&
Short
&
-32768 to 32767
\\
\hline\end{tabulary}

\begin{description}
\item[{Returns:}] \leavevmode
The register data in numerical value (int or float).

\item[{Raises:}] \leavevmode
ValueError, TypeError, IOError

\end{description}

\end{fulllineitems}

\index{read\_registers() (minimalmodbus.Instrument method)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument.read_registers}\pysiglinewithargsret{\sphinxbfcode{read\_registers}}{\emph{registeraddress}, \emph{numberOfRegisters}, \emph{functioncode=3}}{}
Read integers from 16-bit registers in the slave.

The slave registers can hold integer values in the range 0 to 65535 (``Unsigned INT16'').
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
registeraddress (int): The slave register start address (use decimal numbers, not hex).

\item {} 
numberOfRegisters (int): The number of registers to read.

\item {} 
functioncode (int): Modbus function code. Can be 3 or 4.

\end{itemize}

\end{description}

Any scaling of the register data, or converting it to negative number (two's complement)
must be done manually.
\begin{description}
\item[{Returns:}] \leavevmode
The register data (a list of int).

\item[{Raises:}] \leavevmode
ValueError, TypeError, IOError

\end{description}

\end{fulllineitems}

\index{read\_string() (minimalmodbus.Instrument method)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument.read_string}\pysiglinewithargsret{\sphinxbfcode{read\_string}}{\emph{registeraddress}, \emph{numberOfRegisters=16}, \emph{functioncode=3}}{}
Read a string from the slave.

Each 16-bit register in the slave are interpreted as two characters (1 byte = 8 bits).
For example 16 consecutive registers can hold 32 characters (32 bytes).
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
registeraddress (int): The slave register start address (use decimal numbers, not hex).

\item {} 
numberOfRegisters (int): The number of registers allocated for the string.

\item {} 
functioncode (int): Modbus function code. Can be 3 or 4.

\end{itemize}

\item[{Returns:}] \leavevmode
The string (str).

\item[{Raises:}] \leavevmode
ValueError, TypeError, IOError

\end{description}

\end{fulllineitems}

\index{write\_bit() (minimalmodbus.Instrument method)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument.write_bit}\pysiglinewithargsret{\sphinxbfcode{write\_bit}}{\emph{registeraddress}, \emph{value}, \emph{functioncode=5}}{}
Write one bit to the slave.
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
registeraddress (int): The slave register address (use decimal numbers, not hex).

\item {} 
value (int): 0 or 1

\item {} 
functioncode (int): Modbus function code. Can be 5 or 15.

\end{itemize}

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
ValueError, TypeError, IOError

\end{description}

\end{fulllineitems}

\index{write\_float() (minimalmodbus.Instrument method)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument.write_float}\pysiglinewithargsret{\sphinxbfcode{write\_float}}{\emph{registeraddress}, \emph{value}, \emph{numberOfRegisters=2}}{}
Write a floating point number to the slave.

Floats are stored in two or more consecutive 16-bit registers in the slave.

Uses Modbus function code 16.

For discussion on precision, number of registers and on byte order, see {\hyperref[minimalmodbus:minimalmodbus.Instrument.read_float]{\sphinxcrossref{\sphinxcode{read\_float()}}}}.
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
registeraddress (int): The slave register start address (use decimal numbers, not hex).

\item {} 
value (float or int): The value to store in the slave

\item {} 
numberOfRegisters (int): The number of registers allocated for the float. Can be 2 or 4.

\end{itemize}

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
ValueError, TypeError, IOError

\end{description}

\end{fulllineitems}

\index{write\_long() (minimalmodbus.Instrument method)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument.write_long}\pysiglinewithargsret{\sphinxbfcode{write\_long}}{\emph{registeraddress}, \emph{value}, \emph{signed=False}}{}
Write a long integer (32 bits) to the slave.

Long integers (32 bits = 4 bytes) are stored in two consecutive 16-bit registers in the slave.

Uses Modbus function code 16.

For discussion on number of bits, number of registers, the range
and on alternative names, see {\hyperref[minimalmodbus:minimalmodbus.Instrument.read_long]{\sphinxcrossref{\sphinxcode{read\_long()}}}}.
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
registeraddress (int): The slave register start address  (use decimal numbers, not hex).

\item {} 
value (int or long): The value to store in the slave.

\item {} 
signed (bool): Whether the data should be interpreted as unsigned or signed.

\end{itemize}

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
ValueError, TypeError, IOError

\end{description}

\end{fulllineitems}

\index{write\_register() (minimalmodbus.Instrument method)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument.write_register}\pysiglinewithargsret{\sphinxbfcode{write\_register}}{\emph{registeraddress}, \emph{value}, \emph{numberOfDecimals=0}, \emph{functioncode=16}, \emph{signed=False}}{}
Write an integer to one 16-bit register in the slave, possibly scaling it.

The slave register can hold integer values in the range 0 to 65535 (``Unsigned INT16'').
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
registeraddress (int): The slave register address  (use decimal numbers, not hex).

\item {} 
value (int or float): The value to store in the slave register (might be scaled before sending).

\item {} 
numberOfDecimals (int): The number of decimals for content conversion.

\item {} 
functioncode (int): Modbus function code. Can be 6 or 16.

\item {} 
signed (bool): Whether the data should be interpreted as unsigned or signed.

\end{itemize}

\end{description}

To store for example \sphinxcode{value=77.0}, use \sphinxcode{numberOfDecimals=1} if the slave register will hold it as 770 internally.
This will multiply \sphinxcode{value} by 10 before sending it to the slave register.

Similarly \sphinxcode{numberOfDecimals=2} will multiply \sphinxcode{value} by 100 before sending it to the slave register.

For discussion on negative values, the range and on alternative names, see {\hyperref[minimalmodbus:minimalmodbus.Instrument.read_register]{\sphinxcrossref{\sphinxcode{read\_register()}}}}.

Use the parameter \sphinxcode{signed=True} if writing to a register that can hold
negative values. Then negative input will be automatically converted into
upper range data (two's complement).
\begin{description}
\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
ValueError, TypeError, IOError

\end{description}

\end{fulllineitems}

\index{write\_registers() (minimalmodbus.Instrument method)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument.write_registers}\pysiglinewithargsret{\sphinxbfcode{write\_registers}}{\emph{registeraddress}, \emph{values}}{}
Write integers to 16-bit registers in the slave.

The slave register can hold integer values in the range 0 to 65535 (``Unsigned INT16'').

Uses Modbus function code 16.

The number of registers that will be written is defined by the length of the \sphinxcode{values} list.
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
registeraddress (int): The slave register start address (use decimal numbers, not hex).

\item {} 
values (list of int): The values to store in the slave registers.

\end{itemize}

\end{description}

Any scaling of the register data, or converting it to negative number (two's complement)
must be done manually.
\begin{description}
\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
ValueError, TypeError, IOError

\end{description}

\end{fulllineitems}

\index{write\_string() (minimalmodbus.Instrument method)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.Instrument.write_string}\pysiglinewithargsret{\sphinxbfcode{write\_string}}{\emph{registeraddress}, \emph{textstring}, \emph{numberOfRegisters=16}}{}
Write a string to the slave.

Each 16-bit register in the slave are interpreted as two characters (1 byte = 8 bits).
For example 16 consecutive registers can hold 32 characters (32 bytes).

Uses Modbus function code 16.
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
registeraddress (int): The slave register start address  (use decimal numbers, not hex).

\item {} 
textstring (str): The string to store in the slave

\item {} 
numberOfRegisters (int): The number of registers allocated for the string.

\end{itemize}

\end{description}

If the textstring is longer than the 2*numberOfRegisters, an error is raised.
Shorter strings are padded with spaces.
\begin{description}
\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
ValueError, TypeError, IOError

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{PARITY (in module minimalmodbus)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.PARITY}\pysigline{\sphinxcode{minimalmodbus.}\sphinxbfcode{PARITY}\sphinxstrong{ = `N'}}
Default value for the parity. See the pySerial module for documentation. Defaults to serial.PARITY\_NONE

\end{fulllineitems}

\index{STOPBITS (in module minimalmodbus)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.STOPBITS}\pysigline{\sphinxcode{minimalmodbus.}\sphinxbfcode{STOPBITS}\sphinxstrong{ = 1}}
Default value for the number of stopbits (int).

\end{fulllineitems}

\index{TIMEOUT (in module minimalmodbus)}

\begin{fulllineitems}
\phantomsection\label{minimalmodbus:minimalmodbus.TIMEOUT}\pysigline{\sphinxcode{minimalmodbus.}\sphinxbfcode{TIMEOUT}\sphinxstrong{ = 0.05}}
Default value for the timeout value in seconds (float).

\end{fulllineitems}



\section{stepperMotor module}
\label{stepperMotor:steppermotor-module}\label{stepperMotor::doc}\label{stepperMotor:module-stepperMotor}\index{stepperMotor (module)}\index{StepperMotor (class in stepperMotor)}

\begin{fulllineitems}
\phantomsection\label{stepperMotor:stepperMotor.StepperMotor}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{stepperMotor.}\sphinxbfcode{StepperMotor}}{\emph{name}, \emph{adress}, \emph{master}, \emph{serialPort='/dev/ttyUSB0'}, \emph{baudrate=19200}, \emph{stopbits=1}, \emph{parity='N'}, \emph{timeout=0.05}, \emph{standardWaitTime=0.02}, \emph{waitForPingTime=0.2}, \emph{maxFailCounter=50}}{}
Bases: {\hyperref[minimalmodbus:minimalmodbus.Instrument]{\sphinxcrossref{\sphinxcode{minimalmodbus.Instrument}}}}, \sphinxcode{object}

An Oriental Motor stepper motor. This class uses minimalmodbus to
communicate over Modbus/RS-485 with the motor.

\begin{notice}{note}{Note:}
Oriental Motors uses upper and lower registers (each 16 bit). Only lower registers are
supported in this class. If you have to store values greater than 2**16 you have to use
upper registers too.
\end{notice}
\begin{description}
\item[{Attributes:}] \leavevmode\begin{itemize}
\item {} 
baudrate: The baudrate of the serial communication

\item {} 
stopbits: Stopbit configuration of the serial communication

\item {} 
parity: Parity configuration of the serial communication

\item {} 
timeout: Modbus timeout

\item {} 
waitForPingTime: Time between pings to the motor to check if its still moving

\item {} 
standardWaitTime: Time to wait after each modbus communication

\item {} 
maxFailCounter: If a communication failes maxFailCounter times a exception is raised

\item {} 
master: An instance of the class which is controlling the motor. Must have an attribute named

\end{itemize}

``isInterrupted'' and a method named ``handleInterrupt''
* registers: See oriental motor documentation

\end{description}
\index{\_\_init\_\_() (stepperMotor.StepperMotor method)}

\begin{fulllineitems}
\phantomsection\label{stepperMotor:stepperMotor.StepperMotor.__init__}\pysiglinewithargsret{\sphinxbfcode{\_\_init\_\_}}{\emph{name}, \emph{adress}, \emph{master}, \emph{serialPort='/dev/ttyUSB0'}, \emph{baudrate=19200}, \emph{stopbits=1}, \emph{parity='N'}, \emph{timeout=0.05}, \emph{standardWaitTime=0.02}, \emph{waitForPingTime=0.2}, \emph{maxFailCounter=50}}{}
Contructor. Initializes everything. See Attributes.
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
name: The stepper motor name

\item {} 
adress: The modbus adress of the motor

\item {} 
serialport: The usb serial port which the motor is attached to

\item {} 
rest: See class Attributes

\end{itemize}

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
None

\end{description}

\end{fulllineitems}

\index{getBitFromRegister() (stepperMotor.StepperMotor method)}

\begin{fulllineitems}
\phantomsection\label{stepperMotor:stepperMotor.StepperMotor.getBitFromRegister}\pysiglinewithargsret{\sphinxbfcode{getBitFromRegister}}{\emph{adress}, \emph{bit}}{}
Reads a bit from a register.
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
adress (int): Register adress

\item {} 
bit (int): Number of the bit

\end{itemize}

\item[{Returns:}] \leavevmode
True or False

\item[{Raises:}] \leavevmode
None

\end{description}

\end{fulllineitems}

\index{getStatus() (stepperMotor.StepperMotor method)}

\begin{fulllineitems}
\phantomsection\label{stepperMotor:stepperMotor.StepperMotor.getStatus}\pysiglinewithargsret{\sphinxbfcode{getStatus}}{\emph{message}}{}~\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
message: The massage to wrap

\end{itemize}

\item[{Returns:}] \leavevmode
A wrapped string containing name and message

\item[{Raises:}] \leavevmode
None

\end{description}

\end{fulllineitems}

\index{goForward() (stepperMotor.StepperMotor method)}

\begin{fulllineitems}
\phantomsection\label{stepperMotor:stepperMotor.StepperMotor.goForward}\pysiglinewithargsret{\sphinxbfcode{goForward}}{}{}
Starts forward moving of the motor.
Args:
\begin{quote}

None
\end{quote}
\begin{description}
\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
None

\end{description}

\end{fulllineitems}

\index{goHome() (stepperMotor.StepperMotor method)}

\begin{fulllineitems}
\phantomsection\label{stepperMotor:stepperMotor.StepperMotor.goHome}\pysiglinewithargsret{\sphinxbfcode{goHome}}{}{}
Drives the motor to home position.
Args:
\begin{quote}

None
\end{quote}
\begin{description}
\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
None

\end{description}

\end{fulllineitems}

\index{goReverse() (stepperMotor.StepperMotor method)}

\begin{fulllineitems}
\phantomsection\label{stepperMotor:stepperMotor.StepperMotor.goReverse}\pysiglinewithargsret{\sphinxbfcode{goReverse}}{}{}
Starts reverse moving of the motor.
Args:
\begin{quote}

None
\end{quote}
\begin{description}
\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
None

\end{description}

\end{fulllineitems}

\index{readRegisterSafe() (stepperMotor.StepperMotor method)}

\begin{fulllineitems}
\phantomsection\label{stepperMotor:stepperMotor.StepperMotor.readRegisterSafe}\pysiglinewithargsret{\sphinxbfcode{readRegisterSafe}}{\emph{adress}}{}
Reads a value from a register making sure the communication was successfull.
Raises an exception if the communication failes maxFailCounter times.
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
adress (int): The adress to from

\end{itemize}

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
IOError

\end{description}

\end{fulllineitems}

\index{startOperation() (stepperMotor.StepperMotor method)}

\begin{fulllineitems}
\phantomsection\label{stepperMotor:stepperMotor.StepperMotor.startOperation}\pysiglinewithargsret{\sphinxbfcode{startOperation}}{\emph{operationNumber}}{}
Starts a operation which is stored in the operation registers.
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
operationNumber (int): The operation number to start

\end{itemize}

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
ValueError if the operation number is invalid

\end{description}

\end{fulllineitems}

\index{stopMoving() (stepperMotor.StepperMotor method)}

\begin{fulllineitems}
\phantomsection\label{stepperMotor:stepperMotor.StepperMotor.stopMoving}\pysiglinewithargsret{\sphinxbfcode{stopMoving}}{}{}
Stops the motor.
\begin{description}
\item[{Args:}] \leavevmode
None

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
None

\end{description}

\end{fulllineitems}

\index{waitFor() (stepperMotor.StepperMotor method)}

\begin{fulllineitems}
\phantomsection\label{stepperMotor:stepperMotor.StepperMotor.waitFor}\pysiglinewithargsret{\sphinxbfcode{waitFor}}{}{}
Waits for the motor to finish the operation.
\begin{description}
\item[{Args:}] \leavevmode
None

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
None

\end{description}

\end{fulllineitems}

\index{writeOperationMode() (stepperMotor.StepperMotor method)}

\begin{fulllineitems}
\phantomsection\label{stepperMotor:stepperMotor.StepperMotor.writeOperationMode}\pysiglinewithargsret{\sphinxbfcode{writeOperationMode}}{\emph{operationMode}, \emph{operationNumber}}{}
Writes the operation mode for a operation number.
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
operationMode (0\textbar{}1): The operation mode for the operation. 0 for incremental,

\end{itemize}

1 for absolute
* operationNumber (int)

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
ValueError

\end{description}

\end{fulllineitems}

\index{writeOperationPosition() (stepperMotor.StepperMotor method)}

\begin{fulllineitems}
\phantomsection\label{stepperMotor:stepperMotor.StepperMotor.writeOperationPosition}\pysiglinewithargsret{\sphinxbfcode{writeOperationPosition}}{\emph{operationPosition}, \emph{operationNumber}}{}
Writes the operation position for a operation number.
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
operationPosition (int): The steps to move for the operation number

\item {} 
operationNumber (int)

\end{itemize}

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
ValueError

\end{description}

\end{fulllineitems}

\index{writeOperationSpeed() (stepperMotor.StepperMotor method)}

\begin{fulllineitems}
\phantomsection\label{stepperMotor:stepperMotor.StepperMotor.writeOperationSpeed}\pysiglinewithargsret{\sphinxbfcode{writeOperationSpeed}}{\emph{operationSpeed}, \emph{operationNumber}}{}
Writes the operation speed for a operation number.
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
operationSpeed (int): The speed in Hz the operation is performed

\item {} 
operationNumber (int)

\end{itemize}

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
ValueError

\end{description}

\end{fulllineitems}

\index{writeRegisterSafe() (stepperMotor.StepperMotor method)}

\begin{fulllineitems}
\phantomsection\label{stepperMotor:stepperMotor.StepperMotor.writeRegisterSafe}\pysiglinewithargsret{\sphinxbfcode{writeRegisterSafe}}{\emph{adress}, \emph{value}}{}
Writes a value to a register making sure the communication was successfull.
Raises an exception if the communication failes maxFailCounter times.
\begin{description}
\item[{Args:}] \leavevmode\begin{itemize}
\item {} 
adress (int): The adress to write to

\item {} 
value (int): The value to write

\end{itemize}

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
IOError

\end{description}

\end{fulllineitems}

\index{writeToInputRegister() (stepperMotor.StepperMotor method)}

\begin{fulllineitems}
\phantomsection\label{stepperMotor:stepperMotor.StepperMotor.writeToInputRegister}\pysiglinewithargsret{\sphinxbfcode{writeToInputRegister}}{\emph{value}}{}
Writes a value to the input register and resets it.
\begin{description}
\item[{Args:}] \leavevmode
None

\item[{Returns:}] \leavevmode
None

\item[{Raises:}] \leavevmode
None

\end{description}

\end{fulllineitems}


\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{b}
\item {\texttt{bohrvorrichtung}}, \pageref{bohrvorrichtung:module-bohrvorrichtung}
\item {\texttt{button}}, \pageref{button:module-button}
\indexspace
\bigletter{c}
\item {\texttt{commands}}, \pageref{commands:module-commands}
\item {\texttt{communicationUtilities}}, \pageref{communicationUtilities:module-communicationUtilities}
\indexspace
\bigletter{g}
\item {\texttt{gui}}, \pageref{gui:module-gui}
\indexspace
\bigletter{m}
\item {\texttt{minimalmodbus}}, \pageref{minimalmodbus:module-minimalmodbus}
\indexspace
\bigletter{s}
\item {\texttt{stepperMotor}}, \pageref{stepperMotor:module-stepperMotor}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
